# Стек в ассемблере

## Основные концепции

Стек – это специальная область памяти, которая работает по принципу "последним пришел – первым ушел" (LIFO). 

## Применение стека

Стек используется для временного хранения данных, таких как:

- **Адрес возврата**: При вызове функции в стек помещается адрес, по которому программа должна вернуться после завершения функции
- **Аргументы функций**: Перед вызовом функции аргументы передаются через стек
- **Локальные переменные**: В теле функции переменные могут размещаться в стеке

## Зачем очищать стек

### Корректное управление памятью
После вызова функции в стек попадают параметры. Если их не "убирать" (то есть не корректировать указатель стека), указатель будет смещаться, и это может привести к потере контроля над стеком.

### Предотвращение ошибок
Если стек не будет очищен, возможно возникновение ошибок, таких как переполнение стека или повреждение данных, что может привести к некорректной работе программы или даже её сбою.

### Сохранение целостности вызовов функций
Очищение стека позволяет вернуть его в исходное состояние перед следующим вызовом функции, что важно для корректного исполнения программ.

## Пример работы со стеком

В типичном коде после вызова функций (например, `printf` и `scanf`) происходит корректировка указателя стека с помощью команд вроде `add esp, 4` или `add esp, 8`. Это позволяет "удалить" параметры, переданные в функцию, гарантируя, что стек остается правильно выровненным и готов для следующих операций.

### Основные команды для работы со стеком

| Команда                 | Описание                                                 |
|-------------------------|----------------------------------------------------------|
| `push регистр/значение` | Помещает значение в стек                                 |
| `pop регистр`           | Извлекает значение из стека в регистр                    |
| `call метка`            | Вызов процедуры (помещает адрес возврата в стек)         |
| `ret`                   | Возврат из процедуры (извлекает адрес возврата из стека) |

## Адресация и работа с памятью

В ассемблере существует несколько способов обращения к данным в памяти.

### Прямая и косвенная адресация

#### Косвенная адресация (обращение к содержимому ячейки памяти)

`mov eax, [data]`    ; Загружает в регистр eax значение, хранящееся по адресу data


Квадратные скобки `[]` говорят процессору "возьми значение ПО АДРЕСУ, а не сам адрес". Это похоже на разыменование указателя в языках высокого уровня.

#### Прямая адресация (работа с адресом)

`mov ebx, data`      ; Загружает в регистр ebx сам адрес переменной data
`mov eax, ebx`       ; Копирует адрес из ebx в eax

Здесь в регистр загружается не содержимое ячейки памяти, а её адрес.

### Примеры с пояснениями

Предположим, у нас есть в памяти:

`data DD 42`         ; Резервируем 4 байта (двойное слово) и инициализируем значением 42

| Команда | Результат | Пояснение |
|---------|-----------|-----------|
| `mov eax, data` | В eax помещается адрес переменной | Например, если data находится по адресу 0x8048000, то eax = 0x8048000 |
| `mov eax, [data]` | В eax помещается значение переменной | eax = 42 (значение, хранящееся по адресу data) |
| `mov ebx, data` -> `mov eax, [ebx]` | В eax помещается значение по адресу в ebx | Сначала ebx = 0x8048000, затем eax = 42 |

### Операции с памятью и указателем стека

`push eax`           ; Помещает значение регистра eax в стек
`push dword [var]`   ; Помещает в стек значение из памяти по адресу var
`pop ebx`            ; Извлекает значение из стека в регистр ebx

`lea eax, [ebx+8]`   ; Load Effective Address - вычисляет адрес [ebx+8] и помещает его в eax
                   ; (НЕ загружает содержимое этого адреса)

### Сравнение с указателями в C/C++

В контексте языков высокого уровня:
- `mov eax, [data]` эквивалентно `eax = *data;` (значение по адресу)
- `mov eax, data` эквивалентно `eax = data;` (сам адрес)
- `lea eax, [ebx+8]` эквивалентно `eax = &arr[2];` (если предположить, что ebx указывает на начало массива 4-байтных элементов)