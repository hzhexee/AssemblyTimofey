;==========================================
; ОБЪЯВЛЕНИЕ ПЕРЕМЕННЫХ И СТРУКТУРА ДАННЫХ
;==========================================
; Компиляция и сборка:
;   nasm -f elf64 positive_count.asm -o positive_count.o
;   gcc positive_count.o -o positive_count
;
; Запуск: ./positive_count

section .data        ; Секция данных - здесь объявляются инициализированные данные
    msg_input db "Enter n (max 10): ", 0    ; Сообщение для запроса ввода, заканчивается нулем
    msg_sum db "Sum: ", 0    ; Сообщение для вывода суммы, заканчивается нулем
    newline db 10, 0    ; Символ новой строки (ASCII 10) и завершающий ноль

section .bss         ; Секция неинициализированных данных
    n resb 3        ; Резервируем 3 байта для ввода числа n (до 2 цифр + \n)
    output_buf resb 10  ; Резервируем 10 байт для буфера вывода результата
    sum resd 1      ; Резервируем 4 байта (double word) для хранения суммы

;==========================================
; ИСПОЛНЯЕМЫЙ КОД ПРОГРАММЫ
;==========================================
section .text        ; Секция кода программы
    global _start    ; Объявление глобальной метки _start - точки входа в программу

_start:              ; Начало программы
    ;----------------------------------------
    ; БЛОК ВВОДА-ВЫВОДА: Приглашение для ввода
    ; Отображает сообщение с просьбой ввести число
    ;----------------------------------------
    mov eax, 4       ; Системный вызов 4 - write (запись)
    mov ebx, 1       ; Файловый дескриптор 1 - стандартный вывод (stdout)
    mov ecx, msg_input  ; Адрес начала строки для вывода
    mov edx, 18      ; Длина строки в байтах
    int 0x80         ; Вызов ядра Linux для выполнения системного вызова

    ;----------------------------------------
    ; БЛОК ВВОДА-ВЫВОДА: Чтение ввода пользователя
    ; Читает до 3 символов из stdin в буфер n
    ;----------------------------------------
    mov eax, 3       ; Системный вызов 3 - read (чтение)
    mov ebx, 0       ; Файловый дескриптор 0 - стандартный ввод (stdin)
    mov ecx, n       ; Адрес буфера для сохранения введенных данных
    mov edx, 3       ; Максимальное количество байт для чтения (2 цифры + \n)
    int 0x80         ; Вызов ядра Linux

    ;==========================================
    ; БЛОК ОБРАБОТКИ ВВОДА: Преобразование ASCII в число
    ; Анализирует ввод, преобразует ASCII-символы в числовое значение,
    ; проверяет корректность ввода и соответствие диапазону 1-10
    ;==========================================
    
    ;----------------------------------------
    ; Подблок: Подготовка к преобразованию
    ;----------------------------------------
    xor eax, eax     ; Обнуляем регистр eax (eax = 0)
    movzx ebx, byte [n]  ; Загружаем первую цифру в ebx с расширением нулями
    
    ;----------------------------------------
    ; Подблок: Проверка первого символа
    ;----------------------------------------
    sub ebx, '0'     ; Вычитаем ASCII-код '0' для конвертации символа в число
    cmp ebx, 9       ; Сравниваем с 9 (максимальная цифра)
    ja invalid_input ; Если больше 9, значит это не цифра - переход к обработке ошибки
    
    ;----------------------------------------
    ; Подблок: Проверка второго символа
    ;----------------------------------------
    movzx ecx, byte [n+1]  ; Загружаем второй символ в ecx
    cmp ecx, 10     ; Проверяем, является ли второй символ переводом строки (ASCII 10)
    je single_digit ; Если да - число однозначное, переход к метке
    cmp ecx, 13     ; Проверяем, является ли второй символ возвратом каретки (ASCII 13)
    je single_digit ; Если да - число однозначное, переход к метке
    
    ;----------------------------------------
    ; Подблок: Обработка второй цифры для двузначных чисел
    ;----------------------------------------
    sub ecx, '0'    ; Вычитаем ASCII-код '0' для преобразования в число
    cmp ecx, 9      ; Сравниваем с 9
    ja invalid_input ; Если больше 9, значит это не цифра - ошибка ввода
    
    ;----------------------------------------
    ; Подблок: Формирование двузначного числа
    ;----------------------------------------
    imul ebx, 10    ; Умножаем первую цифру на 10 (первая цифра * 10)
    add ebx, ecx    ; Добавляем вторую цифру к результату
    jmp check_range ; Переход к проверке диапазона
    
    ;----------------------------------------
    ; Подблок: Обработка однозначного числа
    ;----------------------------------------
single_digit:       ; Метка для обработки однозначного числа
    ; Если число однозначное, ebx уже содержит нужное значение
    
    ;----------------------------------------
    ; Подблок: Проверка диапазона числа
    ;----------------------------------------
check_range:        ; Метка для проверки диапазона введенного числа
    cmp ebx, 10     ; Сравниваем n (в ebx) с 10
    jbe valid_n     ; Если n <= 10, переход к метке valid_n
    
    ;----------------------------------------
    ; Подблок: Обработка некорректного ввода
    ;----------------------------------------
invalid_input:      ; Метка для обработки некорректного ввода
    mov ebx, 10     ; Если ввод неверный, принудительно устанавливаем n = 10
    
    ;==========================================
    ; БЛОК ВЫЧИСЛЕНИЙ: Сумма от 1 до n
    ; Вычисляет сумму арифметической прогрессии 1+2+...+n
    ;==========================================
valid_n:            ; Метка для продолжения работы с корректным n
    mov ecx, ebx    ; Копируем n в ecx для использования в цикле (counter)
    mov eax, 0      ; Инициализируем сумму нулем (sum = 0)

    ;----------------------------------------
    ; Подблок: Инициализация цикла суммирования
    ;----------------------------------------
    mov edx, 0      ; Инициализируем k = 1 (начальное значение для суммы)
    
    ;----------------------------------------
    ; Подблок: Цикл суммирования
    ;----------------------------------------
sum_loop:           ; Метка начала цикла суммирования
    add eax, edx    ; sum += k
    inc edx         ; k++ (увеличиваем k на 1)
    loop sum_loop   ; Декрементируем ecx и повторяем цикл, пока ecx != 0

    mov [sum], eax  ; Сохраняем результат в переменную sum

    ;==========================================
    ; БЛОК ВЫВОДА РЕЗУЛЬТАТОВ
    ; Выводит метку "Sum: " и значение суммы
    ;==========================================
    
    ;----------------------------------------
    ; Подблок: Вывод метки "Sum: "
    ;----------------------------------------
    mov eax, 4      ; Системный вызов 4 - write
    mov ebx, 1      ; Файловый дескриптор 1 - stdout
    mov ecx, msg_sum ; Адрес строки "Sum: "
    mov edx, 6      ; Длина строки "Sum: " в байтах
    int 0x80        ; Вызов ядра Linux для печати метки

    ;----------------------------------------
    ; Подблок: Вызов подпрограммы вывода числа
    ;----------------------------------------
    mov eax, [sum]  ; Загружаем сумму в eax для преобразования в строку
    call print_number ; Вызываем подпрограмму печати числа

    ;==========================================
    ; БЛОК ЗАВЕРШЕНИЯ ПРОГРАММЫ
    ; Корректно завершает программу с кодом выхода 0
    ;==========================================
    mov eax, 1      ; Системный вызов 1 - exit (выход)
    xor ebx, ebx    ; Код выхода 0 (успешное завершение)
    int 0x80        ; Вызов ядра Linux

;==========================================
; ПОДПРОГРАММА ПЕЧАТИ ЧИСЛА
; Преобразует число в eax в десятичную строку и выводит
;==========================================
print_number:       ; Подпрограмма для вывода числа
    ;----------------------------------------
    ; Подблок: Подготовка к преобразованию
    ;----------------------------------------
    push eax        ; Сохраняем значение eax в стеке
    mov ecx, 10     ; Основание системы счисления (делитель 10 для десятичной)
    mov edi, output_buf + 9  ; Указатель на конец буфера вывода (начинаем с конца)

    ;----------------------------------------
    ; Подблок: Цикл преобразования числа в строку
    ; Последовательно получает цифры числа, начиная с младших разрядов,
    ; и помещает соответствующие им символы в буфер в обратном порядке
    ;----------------------------------------
convert_loop:       ; Цикл преобразования числа в строку
    xor edx, edx    ; Обнуляем EDX перед делением (старшая часть делимого)
    div dword ecx   ; Делим eax на 10, результат в eax, остаток в edx
    add dl, '0'     ; Преобразуем остаток (0-9) в символ ASCII ('0'-'9')
    dec edi         ; Смещаем указатель буфера на предыдущую позицию
    mov [edi], dl   ; Записываем символ в буфер
    test eax, eax   ; Проверяем, не стал ли eax нулем
    jnz convert_loop ; Если не ноль, продолжаем цикл

    ;----------------------------------------
    ; Подблок: Вывод преобразованного числа
    ;----------------------------------------
    mov eax, 4      ; Системный вызов 4 - write
    mov ebx, 1      ; Файловый дескриптор 1 - stdout
    mov ecx, edi    ; Адрес строки для вывода (начало числа в буфере)
    
    ; Вычисляем длину строки на основе нового буфера
    mov edx, output_buf + 10  ; Указатель на конец буфера + 1
    sub edx, edi    ; Вычитаем адрес начала строки для получения длины
    
    int 0x80        ; Вызов ядра Linux для печати числа

    ;----------------------------------------
    ; Подблок: Вывод новой строки и завершение подпрограммы
    ;----------------------------------------
    mov eax, 4      ; Системный вызов 4 - write
    mov ebx, 1      ; Файловый дескриптор 1 - stdout
    mov ecx, newline ; Адрес символа новой строки
    mov edx, 1      ; Длина - 1 байт
    int 0x80        ; Вызов ядра Linux для печати новой строки
    pop eax         ; Восстанавливаем значение eax из стека
    ret             ; Возврат из подпрограммы